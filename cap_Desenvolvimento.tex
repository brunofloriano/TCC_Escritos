%TCIDATA{LaTeXparent=0,0,relatorio.tex}


\chapter{Desenvolvimento}\label{CapDesenvolvimento}

% Resumo opcional. Comentar se não usar.
\resumodocapitulo{Resumo opcional.}

\section{Introdu\c{c}\~{a}o}

%Na introdu\c{c}\~{a}o dever\'{a} ser feita uma descri\c{c}\~{a}o geral da
%metodologia que foi seguida para o desenvolvimento. A seguir, \'{e} feita a
%desci\c{c}\~{a}o do sistema desenvolvido. 

Os trabalhos desenvolvidos anteriormente na plataforma quadrúpede do LARA atualizaram-na com componentes adequados para o projeto, como motores mais robustos, \emph{Raspberry Pi}, Arduino, sensores de força e acelerômetro, e implementaram um movimento balístico que permite ao robô andar com marchas específicas.

O presente trabalho consiste na implementação de um controle de estabilidade na plataforma que permita que esta responda a distúrbios externos, tais como empurrões ou irregularidade no terreno, de modo a manter-se na posição desejada, seja parado ou durante o movimento, sem tombar.

Para tal, o distúrbio é, primeiramente, detectado pelo acelerômetro da plataforma. Um controlador, por sua vez, utiliza deste sinal para determinar a resposta desejada de cada pata para a correção do distúrbio e, por fim, esta resposta é acoplada à posição desejada em regime permanente para determinar a posição de cada motor naquele período de amostragem.

\section{Arquitetura do Robô}
O robô quadrúpede possui um total de 12 motores, sendo 3 em cada pata, como pode ser observado na Figura \ref{fig:robo1}. O motor representado mais acima, em cada pata, tem o objetivo de movimentá-la no sentido transversal, isto é, para a esquerda ou direita. Estes motores serão os responsáveis pela correção do distúrbio de rolagem. Os outros dois motores se movimentam no sentido sagital, ou seja, para frente e para trás e, portanto, irão corrigir o distúrbio que provocaria a arfagem. Um destes motores, o mais abaixo de cada pata, atua como um joelho, dividindo-a em duas partes e adicionando mais um grau de liberdade.


\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/robo1}
	\caption{Representação gráfica da plataforma quadrúpede (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:robo1}
\end{figure}

A identificação numérica (de 1 a 12) de cada motor pode ser organizada de acordo com sua pata e o distúrbio que corrige conforme a Tabela 1.

\subsection{Motores}
Os motores utilizados na plataforma são do modelo RX-28 da DYNAMIXEL como o da Figura \ref{fig:motor} \cite{tcc:santos:2016}. Este motor, conforme indicado em seu manual, possui dois modos de operação: o modo posição (\emph{joint mode}) e o modo velocidade (\emph{wheel mode}).

O modo posição possibilita a determinação da posição ângular de cada junta através da escrita dos bytes 30 e 31 da memória de cada motor. Como pode ser observado na Figura \ref{fig:modoposicao}, dispõem-se de 9 bits (ou 1024 níveis de quantização) para representar ângulos de $0^o$ até $300^o$ (há uma zona inválida entre $300^o$ e $360^o$). Dessa forma, pode-se escrever a posição angular desejada com uma resolução de aproximadamente $0.2933^o$. Portanto, a relação entre a posição desejada, em graus, e o valor quantizado que deve ser escrito na memória é

\begin{center}
	Tabela 1: Identificação dos motores
	\\
	\begin{tabular}[b]{ | l | c | r |}
		\hline
		Identificação do motor & Perna & Movimento de Correção \\ \hline
		1 & 3 & Rolagem \\ \hline
		2 & 3 & Arfagem \\ \hline
		3 & 3 & Arfagem (joelho) \\ \hline
		4 & 4 & Rolagem \\ \hline
		5 & 4 & Arfagem \\ \hline
		6 & 4 & Arfagem (joelho) \\ \hline
		7 & 1 & Rolagem \\ \hline
		8 & 1 & Arfagem \\ \hline
		9 & 1 & Arfagem (joelho) \\ \hline
		10 & 2 & Rolagem \\ \hline
		11 & 2 & Arfagem \\ \hline
		12 & 2 & Arfagem (joelho) \\
		\hline
	\end{tabular}
\end{center}

\newpage

\begin{eqnarray}
B_{\theta} = \frac{1023}{300}\theta_i = 3.41\theta_i ,
\end{eqnarray}

\begin{figure} [t]
	\centering
	\includegraphics[width=0.4\textwidth]{Figuras/motor}
	\caption{Motor Rx-28 da Dynamixel (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:motor}
\end{figure}


\noindent em que $B_{\theta}$ é o valor quantizado que deve ser enviado em formato binário para a memória e $\theta_i$ é o ângulo desejado para o i-ésimo motor, em graus.

O modo velocidade, por outro lado, permite a escrita da velocidade que o motor irá aplicar à sua respectiva junta. Neste modo, 10 bits são utilizados para escrever a velocidade sendo o bit mais significativo utilizado para a determinação do sentido de deslocamento (0 para anti-horário e 1 para horário) e os outros 9 para a determinação do módulo da velocidade. Ao contrário do modo posição, o valor máximo de velocidade não é fixo, mas varia conforme a tensão aplicada no motor. Segundo o manual, quando aplicados 16V, a velocidade máxima que pode ser atingida é de 79.4 rpm. Portanto, a velocidade máxima pode ser determinada por 

\begin{eqnarray}
\omega_{max} = V\frac{79.4}{16},
\end{eqnarray}

\noindent em que $\omega_{max}$ é a velocidade máxima, em rpm,  que pode ser aplicada a cada motor e $V$ é sua respectiva tensão. Os motores, na configuração atual da plataforma, trabalha com nível de tensão de 13.3 V e, portanto, permitem uma velocidade de até 66 rpm, ou 6.91 rad/s. Dessa forma, se $\omega_i$ é a velocidade desejada do i-ésimo motor, em rad/s, o valor quantizado $B_{\omega}$ que deve ser enviado à memória (nos bytes 32 e 33) do motor é

\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/modoposicao}
	\caption[Configurações do Modo Posição]{Configurações do Modo Posição (Fonte: \footnotemark)}	
	\label{fig:modoposicao}
\end{figure}

\begin{eqnarray}
B_{\omega} = \frac{1023}{6.91}|\omega_i| = 148|\omega_i|.
\end{eqnarray}

Segundo o manual, para definir qual o modo de operação será utilizado, deve-se alterar os ângulos limites de cada motor, permitindo ou não que o movimento seja limitado. Dessa forma, para selecionar o modo velocidade os ângulos mínimo e máximo devem ser ambos iguais a zero, dessa forma o sistema identifica que não deve haver restrição de movimento. Já para selecionar o modo posição, nenhum dos dois pode ser zero, havendo, dessa forma, uma restrição do movimento. Para garantir a maior abrangência do movimento de cada motor no modo posição, definiu-se o ângulo mínimo como 1 (valor quantizado) e o ângulo máximo como 1023. A definição dos ângulos mínimo e máximo pode ser realizada através dos bytes de 6 a 9 da memória.

\subsection{Sistema Embarcado}
Os principais dispositivos do sistema embarcado são o \emph{Raspberry Pi} e o \emph{Arduino}. O \emph{Arduino} foi configurado, nos trabalhos anteriores com a plataforma, para receber os dados de sensoriamento do robô, que incluem os sensores de força presentes em cada pata e o acelerômetro. Ele envia para o \emph{Raspberry Pi}, via comunicação serial, estes dados já com um tratamento inicial \cite{tcc:porphirio:2017}. No caso específico do acelerômetro, o Arduino envia não apenas os dados dos três eixos (X,Y e Z) mas também os ângulos correspondentes de rolagem e arfagem já calculados.

\footnotetext{http://support.robotis.com/en/product/actuator/dynamixel/rx\_series/rx-28.htm\#Actuator\_Address\_06}

O \emph{Raspberry Pi}, por sua vez, atua na posição de servo do sistema, recebendo as medições através da conexão com o \emph{Arduino}, calculando a resposta desejada para cada instante de tempo e enviando as informações para os motores, além de tratar os dados, salvá-los, definir as threads periódicas de controle, escrever as informações na tela e etc. Essas funções são definidas em código em C++, sendo utilizadas as bibliotecas da \emph{Dynamixel} para escrita e leitura da memória de cada motor. A interação do usuário com o \emph{Raspberry Pi} é feita via SSH, utilizando o software \emph{PuTTY}. A Figura \ref{fig:arquitetura} mostra o esquemático do sistema embarcado acima descrito.

\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/Arquitetura}
	\caption{Arquitetura do Sistema Embarcado (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:arquitetura}
\end{figure}

\section{Thread Periódica}
Segundo \cite{book:realtime}, "um sistema real é um sistema que deve satisfazer restrições explícitas e delimitadas de tempo de resposta ou sofrer consequências graves, incluindo a falha". Ainda pela mesma referência, tempo de resposta é o "tempo entre a apresentação das entradas ao sistema e o aparecimento das suas respectivas respostas". Dessa forma, o sistema real deve conseguir responder de forma satisfatória às entradas, dentro de um período específico de tempo. Portanto, nota-se que o sistema de equilíbrio do robô quadrúpede pode ser considerado como um sistema real, uma vez que este necessita responder dentro de certos limites de tempo, caso contrário haverá falha, neste caso, a queda do robô.

Para lidar com tal sistema como um sistema real, implementou-se o controle de estabilidade como uma thread periódica, com período de amostragem $T_{am}$. Uma thread é um processo que é aberto pelo sistema de processamento (neste caso do \emph{Raspberry Pi}), para ser rodado de forma paralela com outros. Isso permite com que aquele processo não sofra a influência dos demais, especialmente no tempo. Uma thread periódica, por sua vez, é uma thread que é chamada a cada período de tempo, neste caso, a cada $T_{am}$ segundos.

Desta forma, a implementação do controle de estabilidade como uma thread periódica permite que este não seja influenciado por outros processos, de modo que o tempo de resposta para a correção dos distúrbios fique em limiares aceitáveis para que não haja falhas. No código desenvolvido, a função \emph{main}, depois de configurar todos os parâmetros necessários, cria um timer com $T_{am}$ segundos de periodicidade que, por sua vez, chama a função de controle sempre que o tempo de amostragem é atingido. Asssim, dois processos acontecem simultaneamente: a função \emph{main} que determina as condições de parada do código e escreve informações na tela e a função de controle que lê os dados do acelerômetro, calcula as devidas respostas e as envia para os motores.

\section{gDataLogger}
O \emph{gDataLogger} é um código em C desenvolvido pelo professor Geovany Araújo Borges para que os dados adquiridos durante o processo (como os ângulos de rolagem e arfagem, a posição dos motores e etc) sejam armazenados em um arquivo com extensão .mat para a posterior leitura pelo software \emph{Matlab}.

O \emph{gDataLogger} foi acoplado no código desenvolvido para o recolhimento e análise dos dados de cada experimento do controle de estabilidade. As principais funções para realizar tal recolhimento são: declarar as variáveis, inserir um valor na variável, atualizar o programa e fechá-lo. Além disso, foi desenvolvido um código no próprio \emph{Matlab} para recolher as informações de cada arquivo .mat, organizá-las e, por fim, plotá-las em um gráfico de forma adequada para a análise.

\section{Controle de Estabilidade}
O princípio do controle de estabilidade adotado pelo presente trabalho se baseia, em grande parte, no trabalho desenvolvido em \cite{article:raibert:0000} e em \cite{article:sousa:2010}. O princípio básico deste controle será, portanto, a utilização de sensores, especificamente do acelerômetro, para a detecção de distúrbios no robô que possam gerar os movimentos indesejados de rolagem (queda para direita ou esquerda) ou arfagem (queda para frente ou para trás). Então, a resposta da i-ésima junta para compensar tal movimento será dada por

\begin{eqnarray} \label{eq:des_inicial}
q_i(t) = K_if_i(d_{roll/pitch}),
\end{eqnarray}

\noindent em que $q_i$ é a resposta do i-ésimo motor (sua posição ou velocidade), $K_i$ é  um ganho que será determinado empiricamente para cada junta, $d_{roll/pitch}$ é o distúrbio detectado pelo acelerômetro  e $f_i$ é uma função linear da i-ésima junta que determina o sinal da resposta $q_i$ para que o movimento final do robô seja de modo a se opor ao movimento gerado pelo distúrbio. Assim $f_i(d_{roll/pitch}) = \pm d_{roll/pitch}$, sendo o sinal determinado empiricamente para cada junta.

Podemos observar que equação \ref{eq:des_inicial} é muito semelhante com a equação \ref{} de \cite{article:sousa:2010}. Como a abordagem a ser utilizada é empírica na determinação de $K_i$ substituiremos a função $f_i(d_{roll/pitch})$ pelo próprio $d_{roll/pitch}$ assumindo, dessa forma, que determinaremos o sinal através do parâmtero $K_i$. Assim $K_i$ será positivo ou negativo dependendo do sentido necessário de cada junta para corrigir o distúrbio.

O distúrbio, $d_{roll/pitch}$, será tratado no presente trabalho como a diferença entre o valor de referência desejado para aquela quantidade (posição ou velocidade) e o valor atual da mesma (medida pelo acelerômetro). Isto se representará como

\begin{eqnarray}
d_{roll/pitch} = r_{roll/pitch} - m_{roll/pitch},
\end{eqnarray}

\noindent em que $r_{roll/pitch}$ é o valor de referência, que no geral será igual a zero, e $m_{roll/pitch}$ é o valor medido a cada instante de amostragem. A equação, portanto, que resume a ideia básica do controle proposto é

\begin{eqnarray}
q_i(t) = K_i(r_{roll/pitch} - m_{roll/pitch}).
\end{eqnarray}

\noindent O sistema básico acima descrito pode ser melhor visualizado pela Figura \ref{fig:diagrama1}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/Diagrama1}
	\caption{Diagrama de Blocos do Sistema Básico}
	\label{fig:diagrama1}
\end{figure}


\subsection{Abordagem Inicial}
A ideia inicial para o controle de estabilidade se baseia na utilização de velocidades ao invés de posições e, consequentemente, do modo velocidade dos motores. Esta abordagem se justifica pela necessidade de uma resposta rápida e não cadenciada das juntas. Com isso, os termos da equação \ref{eq:des_inicial} se tornam velocidades, isto é, $d_{roll/pitch}$ se torna a diferença entre a velocidade angular desejada para a rolagem ou arfagem, $r_{roll/pitch}$, e a velocidade atualmente medida para estas, $\omega_{roll/pitch}$. Da mesma forma, $q_i(t)$ passa ser a velocidade do motor i no instante t, ou seja, $\omega_i(t)$. Remodelando a equação \ref{eq:des_inicial} para as novas definções tem-se

\begin{eqnarray}
\omega_i(t) = K_i(r_{roll/pitch} - \omega_{roll/pitch}).
\end{eqnarray}

Como deseja-se a estabilidade do robô, $r_{roll/pitch}$ será estipulado como igual a zero, uma vez que movimentações que provocam rolagem ou arfagem podem levá-lo à queda. Dessa forma, a equação anterior resultará em

\begin{eqnarray}
\omega_i(t) = K_i( - \omega_{roll/pitch}).
\end{eqnarray}

Como o acelerômetro entrega apenas os ângulos de rolagem e arfagens medidos, deve ser feita uma derivação para obter as velocidades $\omega_{roll/pitch}$. Dessa forma

\begin{eqnarray} \label{eq:controle_velocidade}
\omega_i(t) = -K_i \frac{\mathrm d}{\mathrm d t} \left( \theta_{roll/pitch} \right),
\end{eqnarray}

\noindent em que $\theta_{roll/pitch}$ é o ângulo de rolagem ou arfagem medido pelo acelerômetro. O diagrama de blocos, dessa forma é modificado, resultando na Figura \ref{fig:diagrama2}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Diagrama2}
	\caption{Diagrama de Blocos do Sistema no Modo Velocidade}
	\label{fig:diagrama2}
\end{figure}

Uma vez que o sistema está digitalizado, as equações deve ser discretizadas com o tempo de amostragem $T_{am}$. A equação \ref{eq:controle_velocidade} discretizada, portanto, resulta em

\begin{eqnarray} \label{eq:controle_velocidade_discreto}
\omega_i[k] = -K_i \frac{\theta_{roll/pitch}[k] - \theta_{roll/pitch}[k-1]}{T_{am}}.
\end{eqnarray}

\subsection{Filtro}
A derivação dos ângulos medidos pelo acelerômetro deixa o sistema suscetível a ruídos, uma vez que as frequências mais elevadas são impactadas com um ganho maior. Para mitigar este efeito adicionou-se um filtro passa-baixas após a derivação com frequência de amostragem de $f_c = 1Hz$. A equação que descreve o filtro de forma discretizada é

\begin{eqnarray} \label{filtro}
A_{out}[k] = \frac{1}{1+T_{am}2\pi f_c}A_{out}[k-1] + \frac{T_{am}2\pi f_c}{1+T_{am}2\pi f_c}A[k].
\end{eqnarray}

