%TCIDATA{LaTeXparent=0,0,relatorio.tex}


\chapter{Desenvolvimento}\label{CapDesenvolvimento}

% Resumo opcional. Comentar se não usar.
%\resumodocapitulo{Resumo opcional.}

\section{Introdu\c{c}\~{a}o}

%Na introdu\c{c}\~{a}o dever\'{a} ser feita uma descri\c{c}\~{a}o geral da
%metodologia que foi seguida para o desenvolvimento. A seguir, \'{e} feita a
%desci\c{c}\~{a}o do sistema desenvolvido. 

Os trabalhos desenvolvidos anteriormente na plataforma quadrúpede do LARA não apenas atualizaram-na com componentes adequados para o projeto, como motores mais robustos, \emph{Raspberry Pi}, Arduino, sensores de força e acelerômetro, com também implementaram um movimento balístico que permite ao robô andar com marchas específicas.

O presente trabalho, por sua vez, consiste na implementação de um controle de estabilidade na plataforma que a permita responder a distúrbios externos, tais como empurrões ou irregularidade no terreno, de modo a manter-se na posição desejada, seja parado ou durante o movimento, sem tombar.

Para tal, o distúrbio é, primeiramente, detectado pelo acelerômetro da plataforma. Um controlador, posteriormente, utiliza deste sinal para determinar a resposta desejada de cada pata para a correção do distúrbio e, por fim, esta resposta é acoplada à posição desejada em regime permanente para determinar a posição de cada motor a cada período de amostragem.

\section{Arquitetura do Robô}
O robô quadrúpede possui um total de 12 motores, sendo 3 em cada pata, como pode ser observado na Figura \ref{fig:robo1}. O motor representado mais acima, em cada pata, tem o objetivo de movimentá-la no sentido transversal, isto é, para a esquerda ou direita. Estes motores serão os responsáveis pela correção do distúrbio de rolagem. Os outros dois motores se movimentam no sentido sagital, ou seja, para frente e para trás e, portanto, irão corrigir o distúrbio que provocaria a arfagem. Um destes motores, o mais abaixo de cada pata, atua como um joelho, dividindo-a em duas partes e adicionando um grau de liberdade.


\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/robo1}
	\caption{Representação gráfica da plataforma quadrúpede do LARA (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:robo1}
\end{figure}

A identificação numérica (de 1 a 12) de cada motor pode ser organizada de acordo com sua pata e o distúrbio que corrige conforme a Tabela \ref{TabIdMotores}.

\subsection{Motores}
Os motores utilizados na plataforma são do modelo RX-28 da DYNAMIXEL como o da Figura \ref{fig:motor} \cite{tcc:santos:2016}. Este motor, conforme indicado em seu manual\footnote{http://support.robotis.com/en/product/actuator/dynamixel/rx\_series/rx-28.htm\#Actuator\_Address\_06}, possui dois modos de operação: o modo posição (\emph{joint mode}) e o modo velocidade (\emph{wheel mode}).

O modo posição possibilita a determinação da posição ângular de cada junta através da escrita dos bytes 30 e 31 da memória de cada motor. Como pode ser observado na Figura \ref{fig:modoposicao}, dispõem-se de 9 bits (ou 1024 níveis de quantização) para representar ângulos de $0^o$ até $300^o$ (há uma zona inválida entre $300^o$ e $360^o$). Dessa forma, pode-se escrever a posição angular desejada com uma resolução de aproximadamente $0,2933^o$. Portanto, a relação entre a posição desejada, em graus, e o valor quantizado que deve ser escrito na memória é

\begin{table}[h]
	\caption{Identificação dos motores}
	\label{TabIdMotores}
	\begin{center}
		\begin{tabular}[b]{ | l | c | r |}
			\hline
			Identificação do motor & Pata & Movimento de Correção \\ \hline
			1 & 3 & Rolagem \\ \hline
			2 & 3 & Arfagem \\ \hline
			3 & 3 & Arfagem (joelho) \\ \hline
			4 & 4 & Rolagem \\ \hline
			5 & 4 & Arfagem \\ \hline
			6 & 4 & Arfagem (joelho) \\ \hline
			7 & 1 & Rolagem \\ \hline
			8 & 1 & Arfagem \\ \hline
			9 & 1 & Arfagem (joelho) \\ \hline
			10 & 2 & Rolagem \\ \hline
			11 & 2 & Arfagem \\ \hline
			12 & 2 & Arfagem (joelho) \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\newpage

\begin{eqnarray}
B_{\theta} = \frac{1023}{300}\theta_i = 3,41\theta_i ,
\end{eqnarray}

\begin{figure} [t]
	\centering
	\includegraphics[width=0.4\textwidth]{Figuras/motor}
	\caption{Motor Rx-28 da Dynamixel (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:motor}
\end{figure}


\noindent em que $B_{\theta}$ é o valor quantizado que deve ser enviado em formato binário para a memória e $\theta_i$ é o ângulo desejado para o i-ésimo motor, em graus.

O modo velocidade, por outro lado, permite a escrita da velocidade que o motor irá aplicar à sua respectiva junta. Neste modo, 10 bits são utilizados para escrever a velocidade, sendo o bit mais significativo utilizado para a determinação do sentido de deslocamento (0 para anti-horário e 1 para horário) e os outros 9 para a determinação do módulo da velocidade. Ao contrário do modo posição, o valor máximo de velocidade não é fixo, mas varia conforme a tensão aplicada no motor. Segundo o manual\footnote{http://www.crustcrawler.com/motors/RX28/docs/RX28\_Manual.pdf}, quando aplicados 16V, a velocidade máxima que pode ser atingida é de 79,4 rpm. Portanto, a velocidade máxima pode ser determinada por 

\begin{eqnarray}
\omega_{max} = V\frac{79,4}{16},
\end{eqnarray}

\noindent em que $\omega_{max}$ é a velocidade máxima, em rpm,  que pode ser aplicada a cada motor e $V$ é a sua respectiva tensão. Os motores, na configuração atual da plataforma, trabalha com um nível de tensão de 13,3 V e, portanto, permitem uma velocidade de até 66 rpm, ou 6,91 rad/s. Dessa forma, se $\omega_i$ é a velocidade desejada do i-ésimo motor, em rad/s, o valor quantizado $B_{\omega}$ que deve ser enviado à memória (nos bytes 32 e 33) do motor é

\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/modoposicao}
	\caption[Configurações do Modo Posição]{Configurações do Modo Posição (Adaptado de \footnotemark)}	
	\label{fig:modoposicao}
\end{figure}

\begin{eqnarray} \label{eq:velocidade_quant}
B_{\omega} = \frac{1023}{6,91}|\omega_i| + 1024u(-\omega_i) = 148|\omega_i| + 1024u(-\omega_i),
\end{eqnarray}

\noindent em que u é a função degrau. Ou seja, no caso da equação (\ref{eq:velocidade_quant}), se $\omega_i$ for maior que 0 (sentido anti-horário) então o décimo bit de $B_{\omega}$ será igual a zero e se $\omega_i$ for menor que zero (sentido horário), então adicionar-se-á 1024 ao valor que define o módulo, de forma que o décimo bit seja configurado como 1. O caso em que $\omega_i$ é igual a zero não afeta a análise da função degrau uma vez que, se os 9 bit menos significativos forem 0 o motor não irá gerar qualquer movimento, independentemente do valor do décimo bit. 

Segundo o manual, para definir qual o modo de operação será utilizado, deve-se alterar os ângulos limites de cada motor, permitindo ou não que o movimento seja limitado. Dessa forma, para selecionar o modo velocidade, os ângulos mínimo e máximo devem ser ambos iguais a zero. Consequentemente, o sistema identifica que não deve haver restrição de movimento. Já para selecionar o modo posição, nenhum dos dois pode ser zero, havendo, dessa maneira, uma restrição do movimento. Para garantir a maior abrangência do movimento de cada motor no modo posição, pode-se definir o ângulo mínimo como 1 (valor quantizado) e o ângulo máximo como 1023. A definição dos ângulos mínimo e máximo pode ser realizada através dos bytes de 6 a 9 da memória.

\subsection{Sistema Embarcado}
Os principais dispositivos do sistema embarcado são o \emph{Raspberry Pi} e o \emph{Arduino}. O \emph{Arduino} foi configurado, nos trabalhos anteriores com a plataforma, para receber os dados de sensoriamento do robô, que incluem os sensores de força presentes em cada pata e o acelerômetro. Ele, então, envia para o \emph{Raspberry Pi}, via comunicação serial, estes dados já com um tratamento inicial \cite{tcc:porphirio:2017}. No caso específico do acelerômetro, o \emph{Arduino} envia, não apenas os dados dos três eixos (X,Y e Z), mas também os ângulos correspondentes de rolagem e arfagem já calculados.

\footnotetext{http://support.robotis.com/en/product/actuator/dynamixel/rx\_series/rx-28.htm\#Actuator\_Address\_06}

Tais ângulos possibilitam caracterizar a orientação do robô no espaço, indicando se há uma inclinação no sentido transversal ou sagital, como pode ser observado na Figura \ref{fig:angulos}. Na Fig. \ref{fig:angulos}(a), o robô em estado de equilíbrio (em cinza) é deslocado levemente para a direita (hachurado). Neste caso definimos o ângulo entre o plano horizontal e o plano da base do robô como $\theta_{roll}$, o ângulo de rolagem. Já na Fig. \ref{fig:angulos}(b) o robô em repouso é deslocado para frente, formando, dessa forma, o ângulo $\theta_{pitch}$ entre os dois planos, o ângulo de arfagem.

\begin{figure}[tb]
	\centering
	\mbox{
		\subfigure[Vista frontal]{\includegraphics[width=0.4\textwidth]{Figuras/Robo_rolagem}}\quad\quad
		\subfigure[Vista lateral]{\includegraphics[width=0.4\textwidth]{Figuras/Robo_arfagem}}}
	\caption{Orientações detectáveis pelo acelerômetro}
	\label{fig:angulos}
\end{figure}

O \emph{Raspberry Pi}, por sua vez, é a CPU do sistema, recebendo as medições através da conexão com o \emph{Arduino}, calculando a resposta desejada para cada instante de tempo e enviando as instruções para os motores, além de tratar os dados, salvá-los, definir as threads periódicas de controle, escrever as informações na tela e etc. Essas funções são definidas em código desenvolvido em C++, sendo utilizadas as bibliotecas da \emph{Dynamixel} para escrita e leitura da memória de cada motor. A interação do usuário com o \emph{Raspberry Pi} é feita via SSH, utilizando o software \emph{PuTTY}. A Figura \ref{fig:arquitetura} ilustra as conexões do sistema embarcado acima descrito.

Podemos visualizar o sistema embarcado da plataforma, visto de cima, através da Figura \ref{fig:sistemaembarcado}. À esquerda da imagem está o \emph{Arduino} enquanto o \emph{Raspberry Pi} encontra-se ao centro.

\section{gDataLogger}
O \emph{gDataLogger} é um código em C desenvolvido pelo professor Geovany Araújo Borges para que os dados adquiridos durante o processo (como os ângulos de rolagem e arfagem, a posição dos motores e etc) sejam armazenados em um arquivo com extensão .mat para a posterior leitura através do software \emph{Matlab}.

O \emph{gDataLogger} foi acoplado ao código desenvolvido para o recolhimento e análise dos dados de cada experimento do controle de estabilidade. As principais funções para realizar tal recolhimento são: declarar as variáveis, inserir um valor na variável, atualizar o programa e fechá-lo. Além disso, foi desenvolvido um código no próprio \emph{Matlab} para recolher as informações de cada arquivo .mat, organizá-las e, por fim, plotá-las em um gráfico de forma adequada para a análise.

\begin{figure} [h]
	\centering
	\includegraphics[width=0.8\textwidth]{Figuras/Arquitetura}
	\caption{Arquitetura do Sistema Embarcado (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:arquitetura}
\end{figure}

\section{Thread Periódica}
Segundo \cite{book:realtime}, "um sistema real é um sistema que deve satisfazer restrições explícitas e delimitadas de tempo de resposta ou sofrer consequências graves, incluindo a falha". Ainda pela mesma referência, tempo de resposta é o "tempo entre a apresentação das entradas ao sistema e o aparecimento das suas respectivas respostas". Dessa forma, o sistema real deve conseguir responder de forma satisfatória às entradas, dentro de um período específico de tempo. 

Dada esta definição de sistema em tempo real, nota-se que o sistema de equilíbrio do robô quadrúpede pode ser considerado como tal, uma vez que este necessita responder ao distúrbio (que, neste caso, é a entrada do sistema) dentro de certos limites de tempo, caso contrário haverá falha ou, no âmbito desta análise, a queda do robô.

Para lidar com tal sistema como um sistema real, implementou-se o controle de estabilidade como uma thread periódica, com período de amostragem $T_{am}$. Uma thread é um processo que é aberto pelo sistema de processamento (neste caso do \emph{Raspberry Pi}), para ser rodado de forma paralela com outros. Isso permite que o processo não sofra a influência dos demais, especialmente no tempo de resposta (o processo não precisa esperar que outro termine para poder começar). Uma thread periódica, por sua vez, é uma thread que é chamada a cada período de tempo, neste caso, a cada $T_{am}$ segundos.

Desta forma, a implementação do controle de estabilidade como uma thread periódica permite que este não seja influenciado por outros processos, de modo que o tempo de resposta para a correção dos distúrbios fique em limiares aceitáveis para que não haja falhas. No código desenvolvido, a função \emph{main}, depois de configurar todos os parâmetros necessários, cria um timer com $T_{am}$ segundos de periodicidade que, por sua vez, chama a thread de controle sempre que o tempo de amostragem é atingido. Asssim, dois processos acontecem simultaneamente: a função \emph{main}, que determina as condições de parada do código e escreve informações na tela, e a função de controle que lê os dados do acelerômetro, calcula as devidas respostas e as envia para os motores.

O valor de $T_{am}$ foi, a princípio, estipulado como 0,1 segundos. Porém, percebeu-se através de diversos testes, e com auxílio do gDataLogger para a medição do tempo, que a leitura da própria função de controle (linha a linha do código) durava cerca de 35 a 40 ms. Este tempo representa aproximadamente 40\% do tempo de amostragem proposto sendo, dessa forma, uma valor bastante elevado e que pode prejudicar a dinâmica do sistema em tempo real. Por este motivo, estabeleceu-se que a leitura do código não deveria exceder em 20\% o tempo de amostragem.

\begin{figure} [t]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/sistemaembarcado}
	\caption{Vista de cima do sistema embarcado}
	\label{fig:sistemaembarcado}
\end{figure}

Após vários testes para tentar diminuir o tempo de leitura do código, descobriu-se que este tempo elevado ocorre devido às leituras e escritas na memória dos motores, utilizadas para obter os seus valores de posição e velocidade assim como aplicá-los. Uma vez que estas funções são essenciais para o desenvolvimento do projeto e, portanto, não podem ser eliminadas, decidiu-se por aumentar o tempo de amostragem $T_{am}$ para 0,2 segundos. Neste caso, o tempo de leitura do código passa a ser aproximadamente 20\% de $T_{am}$ e, assim, um valor aceitável para o sistema em tempo real.

\section{Controle de Estabilidade}
O princípio do controle de estabilidade adotado pelo presente trabalho se baseia, em grande parte, no trabalho desenvolvido em \cite{article:raibert:0000} e em \cite{article:sousa:2010}. O princípio básico deste controle consiste na utilização de sensores para a aquisição das informações do estado atual do robô e a subsequente aplicação de respostas aos motores baseadas nestes dados. Mais especificamente, a resposta de cada motor i (em que i varia entre 1 e 12) será dada pela multiplicação do distúrbio detectado pelos sensores por um ganho $K_i$ obtido empiricamente para cada junta. 

Para a implementação do controle desejado, o sensoriamento será feito através do acelerômetro, responsável pela detecção de distúrbios no robô que possam gerar os movimentos indesejados de rolagem, $d_{roll}$ (queda para direita ou esquerda) ou arfagem, $d_{pitch}$ (queda para frente ou para trás). Então, a resposta da i-ésima junta para compensar tal movimento será dada por

\begin{eqnarray} \label{eq:des_inicial}
q_i(t) = \pm K_id_{roll/pitch}(t),
%\omega_i(t) = K_id_{roll/pitch}(t)
\end{eqnarray}

\noindent em que $q_i$ é a resposta do i-ésimo motor (sua posição ou velocidade), $K_i$ é  um ganho adimensional que será determinado empiricamente para cada junta e $d_{roll/pitch}$ é o distúrbio detectado pelo acelerômetro\footnote{A notação $x_{roll/pitch}$, que será utilizada neste trabalho, indica que o termo pode ser substituído por $x_{roll}$ ou $x_{pitch}$ dependendo do motor em questão. Por exemplo, o motor 1 corrige o movimento de rolagem então os termos $x_{roll/pitch}$ serão substituídos por $x_{roll}$.}.

O sinal de $q_i(t)$ será determinado empiricamente de modo que a resposta da i-ésima junta seja tal que gere um movimento final no robô que se oponha ao movimento gerado pelo distúrbio. Por exemplo, se o acelerômetro detecta uma queda para à esquerda do robô, as juntas responsáveis pela rolagem devem se movimentar no sentido tal que o robô sofra um movimento para a direita.

Podemos observar que a equação (\ref{eq:des_inicial}) é muito semelhante com as equações (\ref{empirico1}) e (\ref{empirico2}) de \cite{article:sousa:2010}. Como a abordagem a ser utilizada também é empírica na determinação de $K_i$, incorporaremos o sinal $\pm$ ao ganho,  assumindo, dessa forma, que determinaremos o sinal através do parâmtero $K_i$. Assim, $K_i$ será positivo ou negativo dependendo do sentido necessário de cada junta para corrigir o distúrbio.

O distúrbio, $d_{roll/pitch}$, por sua vez, será tratado no presente trabalho como a diferença entre o valor de referência desejado para aquela quantidade (posição ou velocidade) e o valor atual da mesma (medida pelo acelerômetro). Isto se representará como

\begin{eqnarray}
d_{roll/pitch}(t) = r_{roll/pitch}(t) - m_{roll/pitch}(t),
\end{eqnarray}

\noindent em que $r_{roll/pitch}$ é o valor de referência, que no geral será igual a zero, e $m_{roll/pitch}$ é o valor medido a cada instante de amostragem. A equação, portanto, que resume a ideia básica do controle proposto é

\begin{eqnarray} \label{eq:basica_final}
q_i(t) = K_i(r_{roll/pitch}(t) - m_{roll/pitch}(t)).
\end{eqnarray}

%\noindent O sistema básico acima descrito pode ser melhor visualizado pela Figura \ref{fig:diagrama1}.

%\begin{figure} [!b]
%	\centering
%	\includegraphics[width=0.6\textwidth]{Figuras/Diagrama1}
%	\caption{Diagrama de Blocos do Sistema Básico}
%	\label{fig:diagrama1}
%\end{figure}


\subsection{Abordagem Inicial}
A ideia inicial para o controle de estabilidade se baseia na utilização de velocidades e, portanto, do modo velocidade dos motores, ao invés de posições. Esta abordagem se justifica pela necessidade de uma resposta não cadenciada das juntas. Consequentemente, os termos da equação (\ref{eq:basica_final}) serão caracterizados como velocidades, isto é, $r_{roll/pitch}$ será a velocidade angular desejada para a rolagem ou arfagem, $\omega_r$, e $m_{roll/pitch}$, a velocidade atualmente medida para estes movimentos, que reescreveremos como $\omega_{roll/pitch}$. Da mesma forma, $q_i(t)$ será descrito como a velocidade do motor i no instante t, ou seja, $\omega_i(t)$. Remodelando a equação (\ref{eq:des_inicial}) para as novas definções tem-se

\begin{eqnarray}
\omega_i(t) = K_i(\omega_{r}(t) - \omega_{roll/pitch}(t)).
\end{eqnarray}

Como deseja-se a estabilidade do robô, $\omega_{r}$ será estipulado como igual a zero, uma vez que movimentações que provocam rolagem ou arfagem podem levá-lo à queda. Dessa forma, a equação anterior resultará em

\begin{eqnarray}
\omega_i(t) = K_i( - \omega_{roll/pitch}(t)).
\end{eqnarray}

Como o acelerômetro entrega apenas os ângulos de rolagem e arfagens medidos, deve ser feita uma derivação para obter as velocidades $\omega_{roll/pitch}$. Dessa forma

\begin{eqnarray} \label{eq:controle_velocidade}
\omega_i(t) = -K_i \frac{\mathrm d}{\mathrm d t} \left( \theta_{roll/pitch}(t) \right),
\end{eqnarray}

\noindent em que $\theta_{roll/pitch}$ é o ângulo de rolagem ou arfagem medido pelo acelerômetro. O diagrama de blocos resultante desta configuração pode ser visualizado na Figura \ref{fig:diagrama2}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Diagrama2}
	\caption{Diagrama de Blocos do Sistema no Modo Velocidade}
	\label{fig:diagrama2}
\end{figure}

Uma vez que o sistema está digitalizado, as equações devem ser discretizadas com o tempo de amostragem $T_{am}$. A equação (\ref{eq:controle_velocidade}) discretizada, portanto, resulta em

\begin{eqnarray} \label{eq:controle_velocidade_discreto}
\omega_i[k] = -K_i \left(\frac{\theta_{roll/pitch}[k] - \theta_{roll/pitch}[k-1]}{T_{am}}\right).
\end{eqnarray}

\subsection{Filtro}
A derivação dos ângulos medidos pelo acelerômetro deixa o sistema suscetível a ruídos, uma vez que as frequências mais elevadas (comum em ruídos) são destacadas com um ganho maior. Para mitigar este efeito, adicionou-se um filtro passa-baixas com ganho DC unitário e frequência de corte de $f_c$ após a derivação. A função de transferência de tal filtro é dada por

\begin{eqnarray} \label{eq:filtrotf}
G_{filtro}(s) = \frac{2\pi f_c}{s+2\pi f_c}.
\end{eqnarray}

A equação que descreve o filtro de forma discretizada é

\begin{eqnarray} \label{eq:filtro}
A_{out}[k] = \frac{1}{1+T_{am}2\pi f_c}A_{out}[k-1] + \frac{T_{am}2\pi f_c}{1+T_{am}2\pi f_c}A_{in}[k].
\end{eqnarray}

\noindent em que $A_{out}$ é a saída do filtro e $A_{in}$ é a sua entrada.

Como a frequência de amostragem $f_{am} = \frac{1}{T_{am}} = 5Hz$, é razoável estipular a frequência de corte do filtro com o valor de 1Hz. Como $T_{am} = 0,2$ e $f_c = 1$ a equação (\ref{eq:filtro}) resulta em

\begin{eqnarray} \label{eq:filtro2}
A_{out}[k] = 0,4431A_{out}[k-1] + 0,5569A_{in}[k].
\end{eqnarray}

O diagrama de blocos com filtro pode ser visualizado na Figura \ref{fig:diagrama3}.

\begin{figure} [b]
	\centering
	\includegraphics[width=1\textwidth]{Figuras/Diagrama3}
	\caption{Diagrama de Blocos do Sistema no Modo Velocidade com Filtro}
	\label{fig:diagrama3}
\end{figure}

\subsection{Torque no Modo Velocidade}

Conforme será melhor aprofundado no capítulo \ref{CapExperimentos}, após alguns testes, percebeu-se que os motores no modo velocidade não exibem torque suficiente para sustentar o próprio peso. Nestes casos, as juntas se movem facilmente por ações externas ao invés de manter a posição fixa (para velocidades nulas). Isto resulta em casos em que, mesmo sem distúrbio, as juntas acabam se movendo pela ação do peso do robô sobre elas e gerando, como resultado, a queda do robô.

Por outro lado, o modo posição apresenta um torque elevado, de modo que ao determinar uma posição específica para cada junta, esta se mantém fixa e não cede facilmente a forças aplicadas externamente. Não foi encontrado ainda o motivo dessa diferença entre os dois modos de operação. Porém, uma vez reconhecida esta diferença, decidiu-se trabalhar no modo posição para obter um controle de estabilidade mais adequado.

\subsection{Controle de Estabilidade no Modo Posição}
Uma vez decidido pelo uso do modo posição dos motores ao invés do modo velocidade, algumas alterações no modelo anteriormente proposto foram necessárias. A equação (\ref{eq:controle_velocidade_discreto}) determina qual a velocidade $\omega_i[k]$ que deve ser aplicada ao i-ésimo motor no instante k. No entanto, como passou-se a trabalhar no modo posição, a informação que deve ser enviada a cada motor é a sua posição e não a sua velocidade. Dessa forma, para obter a posição desejada de cada motor, basta integrar $\omega_i$. No cenário discretizado em que estamos trabalhando, portanto, a posição angular $\theta_i[k]$ de cada motor no instante k será dada por

\begin{eqnarray} \label{eq:controle_posicao_discreto}
\theta_i[k] = \theta_i[k-1] + T_{am}\omega_i[k] = \theta_i[k-1] -T_{am}K_i \left( \frac{\theta_{roll/pitch}[k] - \theta_{roll/pitch}[k-1]}{T_{am}}\right).
\end{eqnarray}

Dessa forma, o diagrama de blocos correspondente a esta nova estrutura adiciona um integrador ao final, como mostra a Figura \ref{fig:diagrama4}.

\begin{figure} [!b]
	\centering
	\includegraphics[width=1.1\textwidth]{Figuras/Diagrama4}
	\caption{Diagrama de Blocos do Sistema no Modo Posição}
	\label{fig:diagrama4}
\end{figure}

\subsection{Determinação dos Ganhos $K_i$} \label{sec:ganhos}

Com o sistema de controle de equilíbrio definido e as juntas capazes de sustentar o peso do robô, foi possível realizar os testes das respostas dos motores aos distúrbios. Dessa forma, pode-se determinar empiricamente o valor de $K_i$ para cada motor de modo a corrigir o distúrbio da maneira mais eficiente possível.

Com a finalidade de auxiliar a determinação destes ganhos, utilizamos a simetria do robô para a agrupar os motores que devem responder de maneira simultânea e no mesmo sentido, como ilustrado nas Figuras \ref{fig:sincronia_roll} e \ref{fig:sincronia_pitch}. Isto permitirá que o ganho de vários motores possam ter a mesma resposta e, consequentemente, o mesmo $K_i$.

No caso da correção do movimento de rolagem, por exemplo, podemos dividir os grupos em patas da direita e patas da esquerda, como na Fig. \ref{fig:sincronia_roll}. Neste caso, os motores referentes às patas da esquerda que corrigem a rolagem (motores 1 e 10, com linhas verticais) terão um ganho $K_i = K_{L}$ enquanto os que são referentes às patas da direita (motores 4 e 7, com linhas horizontais) obedecerão à relação $K_i = K_{R}$, respondendo ao mesmo tempo e no mesmo sentido.


Da mesma forma, a correção do movimento de arfagem, como pode ser observado na Fig. \ref{fig:sincronia_pitch}(a), pode ser feita com as patas da frente (motores 8, 9, 11 e 12, com linhas horizontais), com um ganho $K_{F}$, ou com as patas de trás (motores 2, 3, 5 e 6, com linhas verticais), com um ganho $K_{B}$\footnote{No presente trabalho foram utilizados os subíndices R, L, B e F para indicar, respectivamente, os sentidos da direita (Right), esquerda (Left), para trás (Back) e para frente (Front).}.

No entanto, há uma diferença para o caso da arfagem uma vez que os motores que fazem a correção neste sentido podem, ainda, ser divididos em motores de joelho e motores de cima (ou não-joelho). Aos motores do tipo joelho, ilustrados pela Fig. \ref{fig:sincronia_pitch}(b) com linhas verticais, serão atribuídos um ganho $K_{down}$, e aos motores de cima (com linhas horizontais), um ganho $K_{up}$. Dessa forma, o ganho referente aos motores que corrigem o movimento de arfagem terá duas componentes, uma indicando a localização da pata (na frente ou atrás) e outra indicando se a junta é ou não um joelho. O ganho será dado, portanto, pela multiplicação das duas componentes. Por exemplo, um motor da frente que não esteja em uma junta do tipo joelho, terá o ganho dado por $K_i = K_{F}K_{up}$.

\begin{figure} [t]
	\centering
	\includegraphics[width=0.9\textwidth]{Figuras/robo4b}
	\caption{Motores de rolagem em sincronia}
	\label{fig:sincronia_roll}
\end{figure}

Assim, observando a Tabela \ref{TabIdMotores}, podemos determinar cada $K_i$:

\begin{align} \label{eq:ganhos}
K_{4/7} &= K_{R},\nonumber\\
K_{1/10} &= K_{L},\nonumber\\
K_{2/5} &= K_{B}K_{up},\nonumber\\
K_{3/6} &= K_{B}K_{down},\nonumber\\
K_{8/11} &= K_{F}K_{up},\nonumber\\
K_{9/12} &= K_{F}K_{down}.
\end{align}

\noindent Nesta equação, a representação $K_{m/n}$ indica que ambos $K_m$ e $K_n$, ganhos dos motores m e n, respectivamente, são iguais ao valor do outro lado da igualdade.

\begin{figure}[!b]
	\centering
	\mbox{
		\subfigure[Sincronia por patas]{\includegraphics[width=0.7\textwidth]{Figuras/robo5b}}}\quad\quad
	\subfigure[Sincronia pelo tipo de junta]{\includegraphics[width=0.7\textwidth]{Figuras/robo3b}}
	\caption{Motores de arfagem em sincronia}
	\label{fig:sincronia_pitch}
\end{figure}

Para que cada par de motores acima agrupados possa seguir o movimento no mesmo sentido alguns valores de $K_i$ devem ser corrigidos com um sinal de negativo, uma vez que alguns motores foram montados em configurações contrárias. Tais motores são: 5, 6, 8 e 9. O motor 7, por sua vez, apresenta um amortecimento levemente maior em relação ao seu par e, portanto, foi multiplicado por 1,1 para a devida correção.

A definição do valor de cada uma dessas componentes será feita de forma empírica através de testes reais na plataforma, com distúrbios em cada direção estudada, e será melhor detalhada no capítulo \ref{CapExperimentos}.

\subsection{Sentido de Movimentação das Patas} \label{sentido_movimentacao}



A análise seguinte que deve ser observada com relação aos ganhos se relaciona com a resposta desejada para cada grupo de patas em conformidade com o sentido de movimentação do robô. Observando a Figura \ref{fig:quedas}, podemos analisar os movimentos de rolagem e arfagem e, assim, determinar o sentido mais adequado para a movimentação das patas. Nesta imagem, apresenta-se os casos em que, partindo da condição de repouso, o robô é empurrado para a direita (Fig. \ref{fig:quedas}(a)) e para frente (Fig. \ref{fig:quedas}(b)).

\begin{figure}[!b]
	\centering
	\mbox{
		\subfigure[Queda para a direita]{\includegraphics[width=0.4\textwidth]{Figuras/Robo_direita}}\quad\quad
		\subfigure[Queda para frente]{\includegraphics[width=0.4\textwidth]{Figuras/Robo_frente}}}
	\caption{Movimento do Centro de Gravidade durante o distúrbio}
	\label{fig:quedas}
\end{figure}

O círculo escuro no centro da base do robô é a representação do seu Centro de Gravidade (COG).	Pela simetria e distribuição de massa que podemos assumir presentes no quadrúpede, tem-se que a projeção vertical do COG no solo, em condições de repouso, se encontra equidistante das patas tanto no plano sagital quanto no transversal. Dessa forma, tal projeção se localiza no centro do retângulo formado pelas patas. Por simplicidade, esta distância é normalizada para cada plano e, portanto, em repouso é igual a 1.

Na Fig. \ref{fig:quedas}(a), apresenta-se o caso em que um distúrbio é aplicado	na plataforma, anteriormente em repouso, de modo a movimentá-la para a direita do robô (movimento de rolagem). Podemos notar que essa perturbação resulta no deslocamento do centro de gravidade no plano transversal e, consequentemente, na movimentação de sua projeção para a direita. Como resultado, o valor da distância entre tal projeção e as patas da esquerda aumenta por um fator $\epsilon$, enquanto essa relação com as patas da direita diminui pelo mesmo fator.

Dessa forma, considerando os teoremas abordados no item \ref{sec:estabilidade_estatica} deste trabalho, percebemos que a margem de estabilidade estática do robô é prejudicada, uma vez que ela passa a ser igual a $1-\epsilon$. Além disso, nota-se que, para fazer com que essa margem seja corrigida e evitar a instabilidade do robô, as patas da direita devem se mover para a direita. Isso faz com que a distância entre a projeção do COG e as bordas da direita do retângulo formado pelas patas aumente e, com isso, a margem de estabilidade seja corrigida.

Cabe aqui ressaltar que a movimentação das patas da esquerda não influencia a estabilidade neste caso pois, se elas se movessem para a esquerda, a margem de estabilidade não mudaria (uma vez que esta é definida como a menor das distâncias descritas) e, se elas se movessem para a direita, haveria o risco de se criar uma nova margem, porém, ainda menor do que $1-\epsilon$. Conclui-se, então, que apenas as patas da direita devem se mover e que têm de fazê-lo para a direita. O mesmo se aplica caso o movimento perturbador seja para a esquerda (caso em que apenas as patas da esquerda devem se mover para a esquerda).

A mesma análise pode ser realizada para o movimento de arfagem como pode ser observado na Fig. \ref{fig:quedas}(b). Analogamente ao caso anterior, na ocorrência de um distúrbio para a frente do robô apenas as patas dianteiras devem se movimentar e para frente, enquanto uma perturbação para trás deve ser corrigida com um movimento para trás das patas traseiras.

Portanto, pode-se definir que as patas que devem corrigir o distúrbio devem ser apenas aquelas referentes à direção do mesmo e no mesmo sentido. Isso pode ser descrito através da equação

\begin{equation}\label{eq:ganho_condicional}
K_j =
\begin{cases} 
A_j & \text{se $\omega_{roll/pitch}$ for no sentido j}, \\
0 & \text{caso contrário.}
\end{cases}
\end{equation}

\noindent Isto é, se a velocidade detectada ocorrer no sentido j (em que j pode ser igual a R, L, F ou B, dependendo do sentido da queda do robô), o ganho referente a este sentido será diferente de zero e igual ao ganho de resposta, $A_j$, a ser caracterizado empiricamente. Caso não seja detectado nenhum distúrbio no sentido j o ganho referente àquela direção será igual a zero.

Como será melhor abordado no capítulo \ref{CapExperimentos}, os testes empíricos realizados na plataforma, com  aplicação de distúrbios, indicaram que o valor de $A_j$ mais adequado para o controle de estabilidade é igual a 1,5 para todos os sentidos.

\subsection{Juntas do Tipo Joelho}

As juntas do tipo joelho, diferem das outras no que diz respeito ao seu sentido de deslocamento (que se dá no plano longitudinal). Em tal caso, percebeu-se, que o mais adequado para estas juntas é que sigam o movimento contrário ao distúrbio. Isso ocorre porque, ao seguir este sentido, a junta do joelho orienta a pata a aterrissar na vertical. Podemos visualizar melhor os possíveis cenários de orientação desta junta durante a aterrissagem através da Figura \ref{fig:aterrissagem}.

A Fig. \ref{fig:aterrissagem}(a) mostra a pata em condição de sustentação, sem correção de distúrbio, como referência. A Fig. \ref{fig:aterrissagem}(b), por sua vez, apresenta o caso em que a junta do joelho não muda sua configuração durante a correção do distúrbio, ocasionando em uma aterrissagem diagonal. Dessa forma, a pata fica suscetível a deslizar horizontalmente, sob influência do peso do robô. Já a Fig. \ref{fig:aterrissagem}(c) indica a configuração aproximada da pata quando o joelho se move em oposição ao distúrbio. É possível notar que a pata tem uma possibilidade mínima de deslizamento neste caso, devido à sua aterrissagem vertical. Por fim, na Fig. \ref{fig:aterrissagem}(d), é possível visualizar a posição da pata quando o joelho se desloca no sentido do distúrbio. Neste cenário, a pata também pode sofrer o deslizamento horizontal, cedendo ao peso do robô ocasionando em sua queda.

\begin{figure} [t]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Aterrissagem}
	\caption{Configurações das juntas tipo joelho no plano longitudinal durante a aterrissagem}
	\label{fig:aterrissagem}
\end{figure}

Dessa forma, a diferenciação entre juntas do tipo joelho e não-joelho é utilizada apenas para adequar o movimento em conjunto destes motores para que, durante a correção do distúrbio, a pata aterrisse da forma mais vertical possível. Deste modo, é razoável assumir que a definição da resposta para a correção em si, seja dada apenas pelos fatores $K_B$ e $K_F$, enquanto $K_{up}$ e $K_{down}$ são apenas ponderações deste movimento para cada tipo de junta. Portanto, por simplicidade, podemos assumir $K_{up} = 1$, de forma que somente $K_{down}$ deva ser encontrado empiricamente. Neste caso, $K_{down}$ deverá ser negativo para seguir o movimento contrário ao motor de cima. Os teste para a determinação de seu valor serão abordados no capítulo \ref{CapExperimentos}.

%Este movimento do joelho de cada pata não exige um deslocamento elevado quando comparado com as demais juntas. Por isso, determinou-se através dos testes, a serem descritos nos resultados, que o valor mais adequado para $K_{down}$ é -0.4 quando $K_{up}$ é normalizado com valor unitário. Este valor possibilita que os joelhos se movimentem o suficiente para garantir uma aterrissagem sem deslizamentos quando o robô sofre um distúrbio de arfagem.

\subsection{Paralelismo com a Posição Desejada} \label{sec:paralelismo}
Determinados os ganhos $K_i$ de todos os motores, o controle de estabilidade está apto a corrigir os distúrbios, conforme será melhor abordado no capítulo \ref{CapExperimentos}. No entanto, o controle proposto até aqui, caracterizado pela equação (\ref{eq:controle_posicao_discreto}), aplica uma determinada posição $\theta_i$ em cada junta e não a modifica mais até a ocorrência de um novo distúrbio. Isto resulta na permanência do robô na posição de correção, mesmo após o fim da perturbação.

A ação mais adequada para o quadrúpede é de, após a correção do distúrbio, cada junta voltar a uma posição desejada para o regime permanente. Dessa forma, se o robô estiver parado, deseja-se que ele volte à posição inicial após a correção. Da mesma maneira, caso a plataforma esteja em processo de marcha, ela deve continuar sua movimentação normalmente após a estabilidade ser alcançada.

À vista disso, podemos remodelar o controle de equilíbrio com um novo diagrama de blocos, como o da Figura \ref{fig:diagrama5}. Podemos notar que, neste novo modelo, a posição desejada para cada junta é a soma de duas componentes: uma determinada pelo controle de estabilidade $G_1(s)$, que tem como entrada o distúrbio detectado pelo acelerômetro e a outra, determinada pela posição desejada em regime permanente $\theta_i^{\ast}$. Esta será definida pelo geração de marchas da plataforma mas, inicialmente, será dada apenas pela posição inicial das juntas para que o robô permaneça parado.

Nesta remodelação, consideraremos $d_{roll/pitch}$ agora como o erro da posição angular dos ângulos de rolagem e arfagem detectados pelo acelerômetro, e não mais suas velocidades. Consequentemente

\begin{eqnarray}
d_{roll/pitch}(t) = \theta_{r}(t) - \theta_{roll/pitch}(t),
\end{eqnarray}

\noindent em que $\theta_r$ é o ângulo de referência para rolagem e arfagem. Como deseja-se a estabilidade do robô, considerar-se-á $\theta_{r} = 0$. Ou seja, o controle será a feito de modo a manter os ângulos de rolagem e arfagem próximos ou iguais a zero. Logo

\begin{figure} [t]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Diagrama5}
	\caption{Diagrama de Blocos com Paralelismo}
	\label{fig:diagrama5}
\end{figure}

\begin{eqnarray}
d_{roll/pitch}(t) =  - \theta_{roll/pitch}(t).
\end{eqnarray}

A posição do i-ésimo motor, no domínio s será

\begin{eqnarray}
\Theta_i(s) = G_1(s)D(s) + G_2(s)\Theta_i^{\ast}(s).
\end{eqnarray}

Para determinar os controladores $G_1(s)$ e $G_2(s)$ mais adequados, analisaremos as condições de regime permanente desejadas através do teorema do valor final. Segundo este

\begin{eqnarray}
\lim_{t \to \infty} \theta_i(t) = \theta_i(\infty) =  \lim_{s \to 0} s\Theta_i(s)  = \lim_{s \to 0} s(G_1(s)D(s) + G_2(s)\Theta_i^{\ast}(s)).
\end{eqnarray}

Deseja-se que $\theta_i(\infty) = \theta_i^{\ast}(t)$. Para tal, a componente referente ao distúrbio $sG_1(s)D(s)$ deve ser anulada quando s tende a zero, enquanto a componente $sG_2(s)\Theta_i^{\ast}(s)$ deve ser igual a $P_i^{\ast}$, a posição angular do motor i em regime permanente, nesta mesma condição. Para que a primeira condição seja satisfeita, consideremos um distúrbio do tipo degrau, ou seja, $D(s) = \frac{D_k}{s}$, em que $D_k$ é a amplitude do degrau. Logo

\begin{eqnarray}
sG_1(s)D(s) = D_k G_1(s).
\end{eqnarray}

\noindent Para que esta equação seja nula no limite de s tentendo a zero, basta que $G_1(s)$ tenha um zero em $s = 0$. Isto é

\begin{eqnarray}
G_1(s) = \frac{K_d s}{H_1(s)},
\end{eqnarray}

\noindent em que $K_d$ é um ganho que será determinado posteriormente baseado nas abordagens anteriores e $H_1(s)$ é o denominador de $G_1(s)$. Podemos observar que a presença do termo s no numerador da função de transferência implica que a resposta ao distúrbio deve ser alocada em frequências maiores. Dessa forma, podemos caracterizar $G_1(s)$ como um filtro passa-alta, uma vez que a componente DC é desejada como nula e as frequências mais elevadas são utilizadas para corrigir o distúrbio. Além do mais, essa caracterização nos permite determinar o tempo de resposta do sistema para a correção do equilíbrio. Assim

\begin{eqnarray}
G_1(s) = \frac{K_d s}{\tau_d s + 1},
\end{eqnarray}

\noindent em que $\tau_d$ é a constante de tempo do controlador de estabilidade.

Já para que a segunda condição seja atendida também consideraremos $\Theta_i^{\ast}(s)$ como um degrau, ou seja, $\Theta_i^{\ast}(s) = \frac{P_i^{\ast}}{s}$, em que $P_i^{\ast}$ é a amplitude do degrau e, portanto, o valor do ângulo desejado em regime permanente. Dessa forma,

\begin{eqnarray}
sG_2(s)\Theta_i^{\ast}(s) = G_2(s)P_i^{\ast}.
\end{eqnarray}

\noindent Para que a equação acima seja igual $P_i^{\ast}$ quando s tender a zero, $G_2(s)$ deve ser igual 1 nessas condições. Podemos concluir, portanto, que esta componente depende que um ganho unitário seja garantido em DC. A resposta em frequências maiores determina apenas o tempo de resposta do sistema para que este atinja o valor final desejado. Por isso, podemos implmentar $G_2(s)$ como um filtro passa-baixas com ganho DC unitário e frequência de corte variável, a ser determinada empiricamente para obtenção da resposta mais adequada. Portanto

\begin{eqnarray}
G_2(s) = \frac{1}{\tau_p s + 1},
\end{eqnarray}

\noindent em que $\tau_p$ é a constante de tempo da resposta em regime permanente (ou então o inverso da frequência de corte).

Portanto, a posição de cada motor será determinada, no domínio s, por

\begin{eqnarray} \label{eq:tf_final}
\Theta_i(s) = \frac{K_d s}{\tau_d s + 1}D(s) + \frac{1}{\tau_p s + 1}\Theta_i^{\ast}(s).
\end{eqnarray}

\noindent Reorganizando a equação (\ref{eq:tf_final}) e passando-a para o domínio do tempo, podemos obter a equação diferencial que representa o sistema proposto como

\begin{eqnarray}
\ddot{\theta_i}(t)\tau_d \tau_p + \dot{\theta_i}(t)(\tau_d + \tau_p) + \theta_i(t) = K_d \tau_p \ddot{d}(t) + K_d \dot{d}(t) + \tau_d \dot{\theta_i^{\ast}}(t) + \theta_i^{\ast}(t).
\end{eqnarray}

Para obter a equação do sistema discretizado, representar-se-á uma quantidade $x(t)$ (em que x pode ser $\theta_i$, $d$ ou $\theta_i^{\ast}$) como $x[k]$ e as suas derivadas como

\begin{align}
\dot{x}(t) &= \frac{x[k] - x[k-1]}{T_{am}}, \text{e} \nonumber \\ 
\ddot{x}(t) &= \frac{x[k] - 2x[k-1] + x[k-2]}{T_{am}^2}.
\end{align}

Dessa forma, a equação de diferenças do sistema discretizado será

\begin{eqnarray}
\theta_i[k]\left(\alpha + \beta + 1\right) + \theta_i[k-1]\left(-2 \alpha- \beta \right) + \theta_i[k-2]\left(\alpha\right) = b[k],
\end{eqnarray}

\noindent em que $b[k]$ será dado como

\begin{eqnarray}
b[k] = d[k]\left(\gamma + \eta \right) + d[k-1]\left(-2 \gamma - \eta \right) + d[k-2]\left(2 \gamma \right) + \theta_i^{\ast}[k]\left(\lambda + 1\right) - \theta_i^{\ast}[k-1]\lambda,
\end{eqnarray}

\noindent e os coeficientes $\alpha$, $\beta$, $\gamma$, $\eta$ e $\lambda$ são dados por

\begin{align} \label{eq:coeficientes}
\alpha &= \frac{\tau_d \tau_p}{T_{am}^2}, \nonumber \\
\beta &= \frac{\left(\tau_d + \tau_p\right)}{T_{am}}, \nonumber \\
\gamma &= \frac{K_d \tau_p}{T_{am}^2}, \nonumber \\
\eta &= \frac{K_d}{T_{am}}, \nonumber \\
\lambda &= \frac{\tau_d}{T_{am}}.
\end{align}

Portanto, o ângulo $\theta_i[k]$ que deverá ser enviado para o i-ésimo motor no instante k é dado por

\begin{eqnarray}
\theta_i[k] = \frac{b[k] - \theta_i[k-1]\left(-2 \alpha- \beta \right) - \theta_i[k-2]\alpha}{\alpha + \beta + 1}.
\end{eqnarray}

Para determinar o parâmetro $K_d$ do controlador, podemos observar comparativamente as equações (\ref{eq:controle_posicao_discreto}) e (\ref{eq:tf_final}). No primeiro caso, é possível observar que a posição final de cada motor é dado pela soma de uma posição prévia a uma velocidade multiplicada pelo tempo de amostragem e uma constante adimensional. A análise dimensional, portanto, confere para a dimensão de posição angular. Já para o segundo caso, como já foi mencionado anteriormente, o distúrbio $D(s)$ é uma posição angular. A composição $sD(s)$, dessa forma, é a velocidade angular do distúrbio, assim como $\omega_{roll/pitch}$ da primeira equação. Assim, para que a resposta do controlador seja similar ao determinado anteriormente, $K_d$ deve ser a mesma constante multiplicando a velocidade, isto é, $K_i T_{am}$. Portanto,

\begin{eqnarray}
K_d = K_i T_{am}.
\end{eqnarray}

Como já mencionado anteriormente, as constantes $\tau_d$ e $\tau_p$ serão determinada empiricamente através de testes reais na plataforma. Tais experimentos determinarão o tempo mais adequado de resposta para a correção de equilíbrio e para que o robô atinja a resposta em regime permanente. Uma vez que estes valores estiverem estipulados, todos os parâmetros da equação (\ref{eq:coeficientes}) estarão devidamente determinados.

\section{Estrutura Geral do Código}
Podemos, então, condensar as principais informações descritas nas seções anteriores para resumir a estrutura básica do código desenvolvido para o controle de estabilidade. O código foi escrito em C++ e possui as funções \emph{main} e controle como os processos principais. A Figura \ref{fig:diagramaprograma} mostra o digrama montado para ilustrar a estrutura geral do código.

\begin{figure} [!t]
	\centering
	\includegraphics[width=0.7\linewidth]{Figuras/DiagramaPrograma}
	\caption{Diagrama do código desenvolvido}
	\label{fig:diagramaprograma}
\end{figure}


A função \emph{main}, em um primeiro momento, faz todas as inicializações necessárias. Isto inclui abrir a comunicação com os motores e com o \emph{Arduino}, declarar as variáveis que serão alocadas no gDataLogger para aquisição de dados, ativar o modo posição dos motores, declarar a posição inicial e enviá-la para os motores. Em seguida, ela espera alguma tecla ser pressionada para seguir os próximos passos.

Uma vez detectada resposta do teclado, a função \emph{main} cria um timer com tempo de amostragem $T_{am}$ que é configurado para chamar a função de controle sempre $T_{am}$ segundos forem decorridos. Com isso, a thread de controle é criada e a função \emph{main}, a partir de então, permanece em um loop apenas para verificar se a condição de parada foi satisfeita (neste caso a condição de parada é um novo toque em qualquer tecla) e atualizar o gDataLogger.

Se detectada a condição de parada, a função \emph{main} para o timer, fecha o gDataLogger e a conexão com o \emph{Arduino}, libera os motores e, se configurado, exporta os dados para um diretório no site \emph{GitHub}, onde os dados podem ser acessados.

Já a função de controle, a cada vez que é chamada, começa com a medição dos dados do acelerômetro. Em seguida ela passa os dados pelo filtro e calcula os ganhos $K_i$ com base nos dados obtidos. Posteriormente, ela passa os dados para o controlador que, após os devidos cálculos, retorna a posição desejada para a i-ésima junta que, então, é mandada para seu respectivo motor. Por fim, os dados são atualizados para serem utilizados na próxima vez que a função for chamada. Para tal a maioria das variáveis são definidas como variáveis globais, assim elas podem ser armazenadas enquanto a thread não é chamada novamente.

\section{Conclusão}
O controle de estabilidade do quadrúpede sofreu modificações com relação à proposta inicial. No entanto, o princípio fundamental desta abordagem foi mantida ao longo do desenvolvimento do trabalho, sempre buscando a melhor resposta da plataforma através dos testes reais na mesma.

A princípio, o controle foi pensado no modo velocidade, em que cada junta responderia com uma velocidade proporcional à do distúrbio. A constante de proporcionalidade $K_i$ seria determinada empiricamente para cada motor. No entanto, a limitação do torque foi fundamental para reconsiderar este modo de operação.

Neste sentido, o uso do modo posição se mostrou bastante adequado para a finalidade do controle, uma vez que os motores apresentavam um torque bastante elevado para sustentar o peso do robô. Dessa forma, com uma leve modificação, a adição de um integrador, foi possível manter a abordagem inicial de resposta dos motores no modo posição. Assim, o controle se mostrou efetivo para o controle de equilíbrio e os ganhos $K_i$ puderam ser determinados.

Por fim, fez-se necessário integrar a resposta de correção da estabilidade com a posição desejada do robô, seja para manter sua marcha ou para mantê-lo na mesma posição inicial. Para tal, utilizou-se de dois controladores, um para lidar com o distúrbio e outro para tratar da resposta desejada em regime permanente. A resposta de cada motor seria dada, portanto, pela soma de cada uma dessas componentes.

O próximo capítulo apresenta os dados específicos que foram coletados durante estes procedimentos e analisa estas informações para justificar as modificações que foram necessárias durante o desenvolvimento do sistema de controle. Além disso, ele também versará sobre a aquisição dos coeficientes de forma empírica, isto é, dos ganhos $K_i$ e das constantes de tempo $\tau_d$ e $\tau_p$.