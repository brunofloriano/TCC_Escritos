%TCIDATA{LaTeXparent=0,0,relatorio.tex}


\chapter{Desenvolvimento}\label{CapDesenvolvimento}

% Resumo opcional. Comentar se não usar.
\resumodocapitulo{Resumo opcional.}

\section{Introdu\c{c}\~{a}o}

%Na introdu\c{c}\~{a}o dever\'{a} ser feita uma descri\c{c}\~{a}o geral da
%metodologia que foi seguida para o desenvolvimento. A seguir, \'{e} feita a
%desci\c{c}\~{a}o do sistema desenvolvido. 

Os trabalhos desenvolvidos anteriormente na plataforma quadrúpede do LARA atualizaram-na com componentes adequados para o projeto, como motores mais robustos, \emph{Raspberry Pi}, Arduino, sensores de força e acelerômetro, e implementaram um movimento balístico que permite ao robô andar com marchas específicas.

O presente trabalho consiste na implementação de um controle de estabilidade na plataforma que permita que esta responda a distúrbios externos, tais como empurrões ou irregularidade no terreno, de modo a manter-se na posição desejada, seja parado ou durante o movimento, sem tombar.

Para tal, o distúrbio é, primeiramente, detectado pelo acelerômetro da plataforma. Um controlador, por sua vez, utiliza deste sinal para determinar a resposta desejada de cada pata para a correção do distúrbio e, por fim, esta resposta é acoplada à posição desejada em regime permanente para determinar a posição de cada motor naquele período de amostragem.

\section{Arquitetura do Robô}
O robô quadrúpede possui um total de 12 motores, sendo 3 em cada pata, como pode ser observado na Figura \ref{fig:robo1}. O motor representado mais acima, em cada pata, tem o objetivo de movimentá-la no sentido transversal, isto é, para a esquerda ou direita. Estes motores serão os responsáveis pela correção do distúrbio de rolagem. Os outros dois motores se movimentam no sentido sagital, ou seja, para frente e para trás e, portanto, irão corrigir o distúrbio que provocaria a arfagem. Um destes motores, o mais abaixo de cada pata, atua como um joelho, dividindo-a em duas partes e adicionando mais um grau de liberdade.


\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/robo1}
	\caption{Representação gráfica da plataforma quadrúpede (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:robo1}
\end{figure}

A identificação numérica (de 1 a 12) de cada motor pode ser organizada de acordo com sua pata e o distúrbio que corrige conforme a Tabela 1.

\subsection{Motores}
Os motores utilizados na plataforma são do modelo RX-28 da DYNAMIXEL como o da Figura \ref{fig:motor} \cite{tcc:santos:2016}. Este motor, conforme indicado em seu manual, possui dois modos de operação: o modo posição (\emph{joint mode}) e o modo velocidade (\emph{wheel mode}).

O modo posição possibilita a determinação da posição ângular de cada junta através da escrita dos bytes 30 e 31 da memória de cada motor. Como pode ser observado na Figura \ref{fig:modoposicao}, dispõem-se de 9 bits (ou 1024 níveis de quantização) para representar ângulos de $0^o$ até $300^o$ (há uma zona inválida entre $300^o$ e $360^o$). Dessa forma, pode-se escrever a posição angular desejada com uma resolução de aproximadamente $0.2933^o$. Portanto, a relação entre a posição desejada, em graus, e o valor quantizado que deve ser escrito na memória é

\begin{center}
	Tabela 1: Identificação dos motores
	\\
	\begin{tabular}[b]{ | l | c | r |}
		\hline
		Identificação do motor & Perna & Movimento de Correção \\ \hline
		1 & 3 & Rolagem \\ \hline
		2 & 3 & Arfagem \\ \hline
		3 & 3 & Arfagem (joelho) \\ \hline
		4 & 4 & Rolagem \\ \hline
		5 & 4 & Arfagem \\ \hline
		6 & 4 & Arfagem (joelho) \\ \hline
		7 & 1 & Rolagem \\ \hline
		8 & 1 & Arfagem \\ \hline
		9 & 1 & Arfagem (joelho) \\ \hline
		10 & 2 & Rolagem \\ \hline
		11 & 2 & Arfagem \\ \hline
		12 & 2 & Arfagem (joelho) \\
		\hline
	\end{tabular}
\end{center}

\newpage

\begin{eqnarray}
B_{\theta} = \frac{1023}{300}\theta_i = 3.41\theta_i ,
\end{eqnarray}

\begin{figure} [t]
	\centering
	\includegraphics[width=0.4\textwidth]{Figuras/motor}
	\caption{Motor Rx-28 da Dynamixel (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:motor}
\end{figure}


\noindent em que $B_{\theta}$ é o valor quantizado que deve ser enviado em formato binário para a memória e $\theta_i$ é o ângulo desejado para o i-ésimo motor, em graus.

O modo velocidade, por outro lado, permite a escrita da velocidade que o motor irá aplicar à sua respectiva junta. Neste modo, 10 bits são utilizados para escrever a velocidade sendo o bit mais significativo utilizado para a determinação do sentido de deslocamento (0 para anti-horário e 1 para horário) e os outros 9 para a determinação do módulo da velocidade. Ao contrário do modo posição, o valor máximo de velocidade não é fixo, mas varia conforme a tensão aplicada no motor. Segundo o manual, quando aplicados 16V, a velocidade máxima que pode ser atingida é de 79.4 rpm. Portanto, a velocidade máxima pode ser determinada por 

\begin{eqnarray}
\omega_{max} = V\frac{79.4}{16},
\end{eqnarray}

\noindent em que $\omega_{max}$ é a velocidade máxima, em rpm,  que pode ser aplicada a cada motor e $V$ é sua respectiva tensão. Os motores, na configuração atual da plataforma, trabalha com nível de tensão de 13.3 V e, portanto, permitem uma velocidade de até 66 rpm, ou 6.91 rad/s. Dessa forma, se $\omega_i$ é a velocidade desejada do i-ésimo motor, em rad/s, o valor quantizado $B_{\omega}$ que deve ser enviado à memória (nos bytes 32 e 33) do motor é

\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/modoposicao}
	\caption[Configurações do Modo Posição]{Configurações do Modo Posição (Fonte: \footnotemark)}	
	\label{fig:modoposicao}
\end{figure}

\begin{eqnarray}
B_{\omega} = \frac{1023}{6.91}|\omega_i| = 148|\omega_i|.
\end{eqnarray}

Segundo o manual, para definir qual o modo de operação será utilizado, deve-se alterar os ângulos limites de cada motor, permitindo ou não que o movimento seja limitado. Dessa forma, para selecionar o modo velocidade os ângulos mínimo e máximo devem ser ambos iguais a zero, dessa forma o sistema identifica que não deve haver restrição de movimento. Já para selecionar o modo posição, nenhum dos dois pode ser zero, havendo, dessa forma, uma restrição do movimento. Para garantir a maior abrangência do movimento de cada motor no modo posição, definiu-se o ângulo mínimo como 1 (valor quantizado) e o ângulo máximo como 1023. A definição dos ângulos mínimo e máximo pode ser realizada através dos bytes de 6 a 9 da memória.

\subsection{Sistema Embarcado}
Os principais dispositivos do sistema embarcado são o \emph{Raspberry Pi} e o \emph{Arduino}. O \emph{Arduino} foi configurado, nos trabalhos anteriores com a plataforma, para receber os dados de sensoriamento do robô, que incluem os sensores de força presentes em cada pata e o acelerômetro. Ele envia para o \emph{Raspberry Pi}, via comunicação serial, estes dados já com um tratamento inicial \cite{tcc:porphirio:2017}. No caso específico do acelerômetro, o Arduino envia não apenas os dados dos três eixos (X,Y e Z) mas também os ângulos correspondentes de rolagem e arfagem já calculados.

\footnotetext{http://support.robotis.com/en/product/actuator/dynamixel/rx\_series/rx-28.htm\#Actuator\_Address\_06}

O \emph{Raspberry Pi}, por sua vez, atua na posição de servo do sistema, recebendo as medições através da conexão com o \emph{Arduino}, calculando a resposta desejada para cada instante de tempo e enviando as informações para os motores, além de tratar os dados, salvá-los, definir as threads periódicas de controle, escrever as informações na tela e etc. Essas funções são definidas em código em C++, sendo utilizadas as bibliotecas da \emph{Dynamixel} para escrita e leitura da memória de cada motor. A interação do usuário com o \emph{Raspberry Pi} é feita via SSH, utilizando o software \emph{PuTTY}. A Figura \ref{fig:arquitetura} mostra o esquemático do sistema embarcado acima descrito.

\begin{figure} [t]
	\centering
	\includegraphics[width=0.5\textwidth]{Figuras/Arquitetura}
	\caption{Arquitetura do Sistema Embarcado (Fonte: \cite{tcc:porphirio:2017})}
	\label{fig:arquitetura}
\end{figure}

\section{gDataLogger}
O \emph{gDataLogger} é um código em C desenvolvido pelo professor Geovany Araújo Borges para que os dados adquiridos durante o processo (como os ângulos de rolagem e arfagem, a posição dos motores e etc) sejam armazenados em um arquivo com extensão .mat para a posterior leitura pelo software \emph{Matlab}.

O \emph{gDataLogger} foi acoplado no código desenvolvido para o recolhimento e análise dos dados de cada experimento do controle de estabilidade. As principais funções para realizar tal recolhimento são: declarar as variáveis, inserir um valor na variável, atualizar o programa e fechá-lo. Além disso, foi desenvolvido um código no próprio \emph{Matlab} para recolher as informações de cada arquivo .mat, organizá-las e, por fim, plotá-las em um gráfico de forma adequada para a análise.

\section{Thread Periódica}
Segundo \cite{book:realtime}, "um sistema real é um sistema que deve satisfazer restrições explícitas e delimitadas de tempo de resposta ou sofrer consequências graves, incluindo a falha". Ainda pela mesma referência, tempo de resposta é o "tempo entre a apresentação das entradas ao sistema e o aparecimento das suas respectivas respostas". Dessa forma, o sistema real deve conseguir responder de forma satisfatória às entradas, dentro de um período específico de tempo. Portanto, nota-se que o sistema de equilíbrio do robô quadrúpede pode ser considerado como um sistema real, uma vez que este necessita responder dentro de certos limites de tempo, caso contrário haverá falha, neste caso, a queda do robô.

Para lidar com tal sistema como um sistema real, implementou-se o controle de estabilidade como uma thread periódica, com período de amostragem $T_{am}$. Uma thread é um processo que é aberto pelo sistema de processamento (neste caso do \emph{Raspberry Pi}), para ser rodado de forma paralela com outros. Isso permite com que aquele processo não sofra a influência dos demais, especialmente no tempo de resposta (o processo não precisa esperar que outro termine para poder começar). Uma thread periódica, por sua vez, é uma thread que é chamada a cada período de tempo, neste caso, a cada $T_{am}$ segundos.

Desta forma, a implementação do controle de estabilidade como uma thread periódica permite que este não seja influenciado por outros processos, de modo que o tempo de resposta para a correção dos distúrbios fique em limiares aceitáveis para que não haja falhas. No código desenvolvido, a função \emph{main}, depois de configurar todos os parâmetros necessários, cria um timer com $T_{am}$ segundos de periodicidade que, por sua vez, chama a thread de controle sempre que o tempo de amostragem é atingido. Asssim, dois processos acontecem simultaneamente: a função \emph{main}, que determina as condições de parada do código e escreve informações na tela, e a função de controle que lê os dados do acelerômetro, calcula as devidas respostas e as envia para os motores.

O valor de $T_{am}$ foi, a princípio, estipulado como 0.1 segundos. Porém, percebeu-se através de diversos testes, e com auxílio do gDataLogger para a medição do tempo, que a leitura da própria função de controle (linha a linha do código) durava cerca de 35 a 40 ms. Este tempo representa aproximadamente 40\% do tempo de amostragem proposto sendo, dessa forma, uma valor bastante elevado e que pode prejudicar a dinâmica do sistema em tempo real. Por este motivo, estabeleceu-se que a leitura do código não deveria exceder em 20\% o tempo de amostragem.

Após várias testes para tentar diminuir o tempo de leitura do código, descobriu-se que este tempo elevado ocorre devido às leituras e escritas na memória dos motores, utilizadas para obter os seus valores de posição e velocidade assim como aplicá-las. Uma vez que estas funções são essenciais para o desenvolvimento do projeto e, portanto, não podem ser eliminadas, decidiu-se por aumentar o tempo de amostragem $T_{am}$ para 0.2 segundos. Neste caso, o tempo de leitura do código passa a ser aproximadamente 20\% de $T_{am}$ e, assim, um valor aceitável para o sistema em tempo real.

\section{Controle de Estabilidade}
O princípio do controle de estabilidade adotado pelo presente trabalho se baseia, em grande parte, no trabalho desenvolvido em \cite{article:raibert:0000} e em \cite{article:sousa:2010}. O princípio básico deste controle será, portanto, a utilização de sensores, especificamente do acelerômetro, para a detecção de distúrbios no robô que possam gerar os movimentos indesejados de rolagem (queda para direita ou esquerda) ou arfagem (queda para frente ou para trás). Então, a resposta da i-ésima junta para compensar tal movimento será dada por

\begin{eqnarray} \label{eq:des_inicial}
q_i(t) = K_if_i(d_{roll/pitch}),
\end{eqnarray}

\noindent em que $q_i$ é a resposta do i-ésimo motor (sua posição ou velocidade), $K_i$ é  um ganho que será determinado empiricamente para cada junta, $d_{roll/pitch}$ é o distúrbio detectado pelo acelerômetro  e $f_i$ é uma função linear da i-ésima junta que determina o sinal da resposta $q_i$ para que o movimento final do robô seja de modo a se opor ao movimento gerado pelo distúrbio. Assim $f_i(d_{roll/pitch}) = \pm d_{roll/pitch}$, sendo o sinal determinado empiricamente para cada junta.

Podemos observar que a equação \ref{eq:des_inicial} é muito semelhante com a equação \ref{} de \cite{article:sousa:2010}. Como a abordagem a ser utilizada é empírica na determinação de $K_i$ substituiremos a função $f_i(d_{roll/pitch})$ pelo próprio $d_{roll/pitch}$ assumindo, dessa forma, que determinaremos o sinal através do parâmtero $K_i$. Assim, $K_i$ será positivo ou negativo dependendo do sentido necessário de cada junta para corrigir o distúrbio.

O distúrbio, $d_{roll/pitch}$, por sua vez, será tratado no presente trabalho como a diferença entre o valor de referência desejado para aquela quantidade (posição ou velocidade) e o valor atual da mesma (medida pelo acelerômetro). Isto se representará como

\begin{eqnarray}
d_{roll/pitch} = r_{roll/pitch} - m_{roll/pitch},
\end{eqnarray}

\noindent em que $r_{roll/pitch}$ é o valor de referência, que no geral será igual a zero, e $m_{roll/pitch}$ é o valor medido a cada instante de amostragem. A equação, portanto, que resume a ideia básica do controle proposto é

\begin{eqnarray}
q_i(t) = K_i(r_{roll/pitch} - m_{roll/pitch}).
\end{eqnarray}

\noindent O sistema básico acima descrito pode ser melhor visualizado pela Figura \ref{fig:diagrama1}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/Diagrama1}
	\caption{Diagrama de Blocos do Sistema Básico}
	\label{fig:diagrama1}
\end{figure}


\subsection{Abordagem Inicial}
A ideia inicial para o controle de estabilidade se baseia na utilização de velocidades ao invés de posições e, consequentemente, do modo velocidade dos motores. Esta abordagem se justifica pela necessidade de uma resposta rápida e não cadenciada das juntas. Com isso, os termos da equação \ref{eq:des_inicial} se tornam velocidades, isto é, $d_{roll/pitch}$ se torna a diferença entre a velocidade angular desejada para a rolagem ou arfagem, $r_{roll/pitch}$, e a velocidade atualmente medida para estas, $\omega_{roll/pitch}$. Da mesma forma, $q_i(t)$ passa ser a velocidade do motor i no instante t, ou seja, $\omega_i(t)$. Remodelando a equação \ref{eq:des_inicial} para as novas definções tem-se

\begin{eqnarray}
\omega_i(t) = K_i(r_{roll/pitch} - \omega_{roll/pitch}).
\end{eqnarray}

Como deseja-se a estabilidade do robô, $r_{roll/pitch}$ será estipulado como igual a zero, uma vez que movimentações que provocam rolagem ou arfagem podem levá-lo à queda. Dessa forma, a equação anterior resultará em

\begin{eqnarray}
\omega_i(t) = K_i( - \omega_{roll/pitch}).
\end{eqnarray}

Como o acelerômetro entrega apenas os ângulos de rolagem e arfagens medidos, deve ser feita uma derivação para obter as velocidades $\omega_{roll/pitch}$. Dessa forma

\begin{eqnarray} \label{eq:controle_velocidade}
\omega_i(t) = -K_i \frac{\mathrm d}{\mathrm d t} \left( \theta_{roll/pitch} \right),
\end{eqnarray}

\noindent em que $\theta_{roll/pitch}$ é o ângulo de rolagem ou arfagem medido pelo acelerômetro. O diagrama de blocos, dessa forma é modificado, resultando na Figura \ref{fig:diagrama2}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Diagrama2}
	\caption{Diagrama de Blocos do Sistema no Modo Velocidade}
	\label{fig:diagrama2}
\end{figure}

Uma vez que o sistema está digitalizado, as equações deve ser discretizadas com o tempo de amostragem $T_{am}$. A equação \ref{eq:controle_velocidade} discretizada, portanto, resulta em

\begin{eqnarray} \label{eq:controle_velocidade_discreto}
\omega_i[k] = -K_i \frac{\theta_{roll/pitch}[k] - \theta_{roll/pitch}[k-1]}{T_{am}}.
\end{eqnarray}

\subsection{Filtro}
A derivação dos ângulos medidos pelo acelerômetro deixa o sistema suscetível a ruídos, uma vez que as frequências mais elevadas (comum em ruídos) são destacadas com um ganho maior. Para mitigar este efeito, adicionou-se um filtro passa-baixas com ganho DC unitário e frequência de corte de $f_c$ após a derivação. A função de transferência de tal filtro é dada por

\begin{eqnarray} \label{eq:filtrotf}
G_{filtro}(s) = \frac{2\pi f_c}{s+2\pi f_c}.
\end{eqnarray}

A equação que descreve o filtro de forma discretizada é

\begin{eqnarray} \label{eq:filtro}
A_{out}[k] = \frac{1}{1+T_{am}2\pi f_c}A_{out}[k-1] + \frac{T_{am}2\pi f_c}{1+T_{am}2\pi f_c}A_{in}[k].
\end{eqnarray}

Como a frequência de amostragem $f_{am} = \frac{1}{T_{am}} = 5Hz$, é razoável estipular a frequência de corte do filtro com o valor de 1Hz. Como $T_{am} = 0.2$ e $f_c = 1$ a equação \ref{eq:filtro} resulta em

\begin{eqnarray} \label{eq:filtro2}
A_{out}[k] = 0.4431A_{out}[k-1] + 0.5569A_{in}[k].
\end{eqnarray}

O diagrama de blocos com filtro pode ser visualizado na Figura \ref{fig:diagrama3}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Diagrama3}
	\caption{Diagrama de Blocos do Sistema no Modo Velocidade com Filtro}
	\label{fig:diagrama3}
\end{figure}

\subsection{Torque no Modo Velocidade}

Conforme será melhor aprofundado no capítulo de Resultados, após alguns testes, percebeu-se que os motores no modo velocidade não exibem torque suficiente para sustentar o próprio peso. Nestes casos, as juntas se movem facilmente por ações externas ao invés de manter a posição fixa (para velocidades nulas). Isto resulta em casos em que, mesmo sem distúrbio, as juntas acabam se movendo pela ação do peso do robô sobre elas e gerando, como resultado, a queda do robô.

Por outro lado, o modo posição apresenta um torque elevado, de modo que ao determinar uma posição específica para cada junta, esta se mantém fixa e não cede facilmente a forças aplicadas externamente. Não foi encontrado ainda o motivo dessa diferença entre os dois modos de operação. Porém uma vez reconhecida esta diferença decidiu-se trabalhar no modo posição para obter um controle de estabilidade mais adequado.

\subsection{Controle de Estabilidade no Modo Posição}
Uma vez decidido pelo uso do modo posição dos motores ao invés do modo velocidade, algumas alterações ao modelo anteriormente proposto foram necessárias. A equação \ref{eq:controle_velocidade_discreto} determina qual a velocidade $\omega_i[k]$ que deve ser aplicada ao i-ésimo motor no instante k. No entanto, como passou-se a trabalhar no modo posição, a informação que deve ser enviada a cada motor é a sua posição e não a sua velocidade. Dessa forma, para obter a posição desejada de cada motor, basta integrar $\omega_i$. No cenário discretizado em que estamos trabalhando, portanto, a posição angular $\theta_i[k]$ de cada motor no instante k será dada por

\begin{eqnarray} \label{eq:controle_posicao_discreto}
\theta_i[k] = \theta_i[k-1] + T_{am}\omega_i[k] = \theta_i[k-1] -T_{am}K_i \left( \frac{\theta_{roll/pitch}[k] - \theta_{roll/pitch}[k-1]}{T_{am}}\right).
\end{eqnarray}

Dessa forma, o diagrama de blocos correspondente a esta nova estrutura adiciona um integrador ao final, como mostra a Figura \ref{fig:diagrama4}.

\begin{figure} [b]
	\centering
	\includegraphics[width=0.7\textwidth]{Figuras/Diagrama4}
	\caption{Diagrama de Blocos do Sistema no Modo Posição}
	\label{fig:diagrama4}
\end{figure}

\subsection{Determinação dos Ganhos $K_i$}

Com o sistema de controle de equilíbrio definido e as juntas capazes de sustentar o peso do robô, foi possível realizar os testes das respostas dos motores aos distúrbios. Dessa forma, pode-se determinar empiricamente o valor de $K_i$ para cada motor de modo a corrigir o distúrbio da maneira mais eficiente possível.

Para auxiliar na determinação destes ganhos utilizamos a simetria do robô de modo a agrupar as respostas que devem ocorrer de maneira simultânea no mesmo sentido. No caso da correção do movimento de rolagem, por exemplo, podemos dividir os grupos como patas da direita e patas da esquerda. Neste caso, os motores referentes às patas da esquerda que corrigem a rolagem terão um ganho $K_i = K^{esquerda}_{roll}$ enquanto os que são referentes às patas da direita obedecerão à relação $K_i = K^{direita}_{roll}$.

Da mesma forma, a correção do movimento de arfagem pode ser feita com as patas da frente, com um ganho $K^{frente}_{pitch}$, ou com as patas de trás, com um ganho $K^{tras}_{pitch}$. No entanto, há uma diferença para o caso da arfagem uma vez que os motores que fazem a correção neste sentido podem, ainda, ser divididos em motores de joelho, com um ganho $K_{down}$, e os de cima, $K_{up}$. Dessa forma, o ganho referente aos motores que corrigem o movimento de arfagem terá duas componentes, uma indicando a localização da pata (na frente ou atrás) e outra indicando se a junta é ou não um joelho. O ganho será dado, portanto, pela multiplicação das duas componentes. Por exemplo, um motor da frente que não esteja em uma junta do tipo joelho, terá o ganho dado por $K_i = K^{frente}_{pitch}K_{up}$.

Assim, observando a Tabela 1, podemos determinar cada $K_i$:

\begin{eqnarray} \label{eq:ganhos}
K_{4/7} = K^{direita}_{roll},\nonumber\\
K_{1/10} = K^{esquerda}_{roll},\nonumber\\
K_{2/5} = K^{tras}_{pitch}K_{up},\nonumber\\
K_{3/6} = K^{tras}_{pitch}K_{down},\nonumber\\
K_{8/11} = K^{frente}_{pitch}K_{up},\nonumber\\
K_{9/12} = K^{frente}_{pitch}K_{down}.
\end{eqnarray}

Para que cada par de motores acima agrupados possa seguir o movimento no mesmo sentido alguns valores de $K_i$ devem ser corrigidos com um sinal de negativo, uma vez que alguns motores foram montados em configurações contrárias. Tais motores são: 5, 6, 8 e 9. O motor 7, por sua vez, apresenta um amortecimento levemente maior em relação ao seu par e, portanto, foi multiplicado por 1.1 para a devida correção.

A definição do valor de cada uma dessas componentes será feita de forma empírica através de testes reais. Neste sentido, o primeiro fato detectado através dos testes é que a resposta de cada pata deve seguir o movimento do distúrbio. Por exemplo, se o robô é empurrado para a direita, o movimento das patas deve ser avançar no sentido da direita. O mesmo se aplica para o movimento de arfagem, com exceção das juntas do tipo joelho. Neste caso, percebeu-se, empiricamente, que o mais adequado para esta juntas é que estas sigam o movimento contrário. Isso ocorre porque, ao seguir o movimento contrário, a junta do joelho orienta a pata de modo a aterrissar de forma vertical. 

Essa perspectiva influencia os valores da equação \ref{eq:ganhos} em seu sinal. Analisando a resposta dos motores, percebeu-se que os valores positivos seguem exatamente o movimento desejado, exceto para as juntas do tipo joelho, em que o sinal deve ser negativo para seguir o movimento contrário do distúrbio.